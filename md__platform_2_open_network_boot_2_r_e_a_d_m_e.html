<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCore: OpenNetworkBoot</title>
<link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LogoApprox.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCore
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">OpenCore Bootloader</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__platform_2_open_network_boot_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">OpenNetworkBoot</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md13"></a></p>
<p><code>OpenNetworkBoot</code> is an OpenCore boot entry protocol driver which provides PXE and HTTP boot entries if the underlying firmware supports it, or if the required network boot drivers have been loaded using OpenCore. Using the additional network boot drivers provided with OpenCore, when needed, HTTP boot should be available on most firmware even if not natively supported.</p>
<p>See <a href="https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/Configuration.pdf">OpenCore documentation</a> for information on the optional configuration arguments which are available for this driver.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: In this file 'HTTP boot' refers to booting using either <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code> URIs. The additional steps to configure a certificate for <code><a href="https://">https://</a></code> (and to lock <code>OpenNetworkBoot</code> to <code><a href="https://">https://</a></code> only, if required) are covered below. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md14"></a>
PXE Boot</h1>
<p>On almost all firmware, the drivers for PXE boot will already be present; adding <code>OpenNetworkBoot.efi</code> to the OpenCore drivers should produce PXE boot entries.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: On some firmware (e.g. HP) the native network boot drivers are not loaded if the system boots directly to OpenCore and it is necessary to start OpenCore from the firmware boot menu in order to see PXE and HTTP boot entries. (Alternatively, it should be possible to load the network boot stack provided with OpenCore, see end of this document.) </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md15"></a>
HTTP Boot</h1>
<p>On most recent firmware either no or only a few additional drivers are needed for HTTP boot, as most of the required drivers are already present in firmware.</p>
<p>After adding <code>OpenNetworkBoot</code>, if no HTTP boot entries are seen, try adding just the driver <code>HttpBootDxe</code>. If this does not produce network boot entries, try also adding <code>HttpDxe</code> and <code>HttpUtilitiesDxe</code>. If <code><a href="http://">http://</a></code> URIs can be booted but not <code><a href="https://">https://</a></code> try adding <code>TlsDxe.efi</code>.</p>
<p>If the above steps do not work, proceed to the next section to identify which drivers are required.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note 1</b>: When using <code><a href="https://">https://</a></code> as opposed to <code><a href="http://">http://</a></code> URIs, one or more certificates, as required to validate the connection, must be configured on the network boot client. This can be done using OpenNetworkBoot's certificate configuration options, as documented in the <a href="https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/Configuration.pdf">OpenCore documentation</a>. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>Note 2</b>: In some firmware the existing <code>HttpBootDxe</code> driver may produce options which do not work correctly (e.g. blank screen when selected, because they are designed to work with a firmware UI which is not present when OpenCore is running). If so, in order to get working HTTP Boot options it may be necessary to use the <code>UEFI/Unload</code> config setting to unload the existing <code>HttpBootDxe</code> driver before loading the <code>HttpBootDxe</code> driver provided with OpenCore. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>Note 3</b>: In some firmware the existing <code>HttpDxe</code> (and <code>HttpBootDxe</code>) drivers may be locked down to <code><a href="https://">https://</a></code> URIs (even if the machine has no BIOS UI for HTTP Boot; e.g. Dell OptiPlex 3070). This means that while the <code>HttpBootDxe</code> from OpenCore can work with the native <code>HttpDxe</code>, it will only boot from <code><a href="https://">https://</a></code> URIs, giving a failure message otherwise. If <code><a href="http://">http://</a></code> URIs are required, this limitation can be worked around by using the <code>UEFI/Unload</code> config setting to unload the existing <code>HttpDxe</code> driver before loading the <code>HttpDxe</code> driver provided with OpenCore. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>Note 4</b>: During HTTP Boot '<em>Error: Could not retrieve NBP file size from HTTP server</em>' is a very generic error message for 'something went wrong'. It could be that <code><a href="http://">http://</a></code> URIs are not allowed by <code>HttpDxe</code> or <code>HttpBootDxe</code>, or that a file does not exist at the specified URI on the server, or that the certificates (if any) stored in NVRAM could not be used to validate an <code><a href="https://">https://</a></code> URI, or any one of a number of other similar problems. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>Note 5</b>: During HTTP Boot, an initial error such as 'IP address not found' or 'Server response timeout', even if preceded by the above message, may mean that no IP address was issued by DHCP, or that the additional NBP (i.e. boot file) info requested over DHCP was not found. Using <code>dnsmasq</code> as the DHCP helper with the logging options shown below can be helpful to resolve this: any DHCP request which reaches <code>dnsmasq</code> will show a couple of log lines. If these are not seen during a network boot attempt then there is no chance of <code>dnsmasq</code> responding, and network connectivity issues need to be resolved. (It is worth noting that unless blocked, this DHCP request traffic will normally be broadcast between local networks.) If these log lines are seen but <code>dnsmasq</code> does not additionally log that it is responding with NBP information, make sure that it is configured with the correct subnetwork for the client machine. It can help to boot the client computer into an OS to confirm which subnetwork it is on. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md16"></a>
Identifying missing network boot drivers</h1>
<p>The <code>dh</code> command in UEFI Shell (e.g. <code>OpenShell</code> provided with OpenCore) is useful for working out which drivers are missing for network boot.</p>
<p><code>dh -p LoadFile</code> shows available network boot entries. Handles with a device path ending in an IPv4 or IPv6 address should indicate available PXE boot options. Handles with a device path ending in <code>Uri(...)</code> should indicate available HTTP boot options</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note 1</b>: On some systems, there may be additional <code>LoadFile</code> handles with vendor-specific device paths. These may correspond, for instance, to GUI network boot options. These will not produce boot entries when using OpenNetworkBoot. </p>
</blockquote>
<p>After identifying the handles for network boot entries, the other handles just before and after these, in the full list of handles displayed by <code>dh</code>, should correspond to the currently loaded network boot drivers. If there are no LoadFile options, then search in the full handle list for strings such as 'tcp', 'tls', 'http' (normally the native network boot drivers will appear grouped together). Examining the names printed by <code>dh</code> for these handles and comparing them to the available network boot drivers (see Network Boot Stack section) can be used to identify missing drivers.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note 2</b>: On systems with reasonably fast console text output, the <code>-b</code> option can be used with <code>dh</code> (as with most UEFI Shell commands) to display results one page at a time. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>Note 3</b>: For systems with slow console output, it may be more convenient to pipe the results of <code>dh</code> to a file on a convenient file system to examine later, within a booted OS. For example <code>dh &gt; fs0:\dh_dump</code> or: </p>
</blockquote>
<div class="fragment"><div class="line">&gt; fs0:</div>
<div class="line">&gt; dh &gt; dh_dump</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Configuring a network boot server</h1>
<p>In standard PXE and HTTP boot, the network's normal DHCP server responds to a client device's request for an IP address, but a separate DHCP helper service (often running on a different machine from the DHCP server) responds to the device's DHCP extension request to know which network boot program (NBP) to load. It is possible (but less standard, even on enterprise networks; and usually more complex) to configure the main DHCP server to respond to both requests.</p>
<p><b>Note 1</b>: The NBP for HTTP boot can be configured by specifying the <code>--uri</code> flag for <code>OpenNetworkBoot</code>. When using this option, only an HTTP server (and certificate, for HTTPS), needs to be set up, but no DHCP helper service is required.</p>
<p><b>Note 2</b>: No equivalent NBP path option is provided for PXE boot, since the most standard (and recommended) set up is for the program specifying the NBP file and the program serving it via TFTP to be one and the same.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
PXE Boot</h2>
<p>In PXE boot, the NBP is loaded via TFTP, which is a slow protocol not suitable for large files. Standard PXE boot NBPs typically load any further large files which they need using their own network stack and not via TFTP.</p>
<p><code>dnsmasq</code>, WDS, or other options, such as FOGProject, may be used to specify PXE boot responses.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
dnsmasq</h3>
<p><code>dnsmasq</code> can be used to both provide the location of the PXE boot NBP file and then serve it by TFTP.</p>
<p>A basic <code>dnsmasq</code> PXE boot configuration is as follows:</p>
<div class="fragment"><div class="line"># Disable DNS Server</div>
<div class="line">port=0</div>
<div class="line"> </div>
<div class="line"># Run as network boot DHCP proxy</div>
<div class="line">dhcp-range=192.168.10.0,proxy</div>
<div class="line"> </div>
<div class="line"># Identify requested arch</div>
<div class="line"># REF: https://wiki.archlinux.org/title/dnsmasq#PXE_server</div>
<div class="line">dhcp-match=set:arch_x64,option:client-arch,7</div>
<div class="line">dhcp-match=set:arch_x64,option:client-arch,9</div>
<div class="line">dhcp-match=set:arch_ia32,option:client-arch,6</div>
<div class="line"> </div>
<div class="line"># Specify one or more boot options per architecture</div>
<div class="line">pxe-service=tag:arch_x64,x86-64_EFI,&quot;Open Shell&quot;,OpenShell.efi</div>
<div class="line">pxe-service=tag:arch_x64,x86-64_EFI,&quot;Boot Helper&quot;,BootHelper.efi</div>
<div class="line"> </div>
<div class="line"># Enable TFTP support</div>
<div class="line">enable-tftp</div>
<div class="line">tftp-root=/home/mjsbeaton/tftp</div>
</div><!-- fragment --><p>A more advanced configuration might serve different files to different machines, depending on their hardware id. (The same point applies to HTTP boot.) See <code>dnsmasq</code> documentation.</p>
<p>See <b>HTTP Boot</b> <b>dnsmasq</b> section below for command to quickly start <code>dnsmasq</code> for testing.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
WDS</h3>
<p>Windows Deployment Services (WDS, which is incuded with Windows Server) can be used to provide responses to PXE boot requests, and can be configured to serve non-Windows NBP files.</p>
<p><b>Note 1</b>: Certain aspects of WDS are now deprecated: <a href="https://aka.ms/WDSSupport">https://aka.ms/WDSSupport</a></p>
<p><b>Note 2</b>: On certain systems, the OpenCore <code>TextRenderer</code> setting must be set to one of the <code>System</code> values in order to see the early output of <code>wdsmgfw.efi</code> (the NBP served by default by WDS). If this text is not visible, this can be worked round by pressing either <code>F12</code> or <code>Enter</code> in the pause after the program has loaded, in order to access the next screen. The issue of the early text of this software not appearing in some circumstances is not unique to OpenCore: <a href="https://serverfault.com/q/683314">https://serverfault.com/q/683314</a></p>
<h2><a class="anchor" id="autotoc_md21"></a>
HTTP Boot</h2>
<h3><a class="anchor" id="autotoc_md22"></a>
dnsmasq</h3>
<p>Although <code>dnsmasq</code> does not provide complete support for HTTP boot, as it does for PXE boot, its PXE boot features can be used to respond to requests for the location of HTTP boot NBP files.</p>
<p>A basic <code>dnsmasq</code> HTTP boot configuration is as follows:</p>
<div class="fragment"><div class="line"># Disable DNS Server</div>
<div class="line">port=0</div>
<div class="line"> </div>
<div class="line"># Run as PXE Boot DHCP proxy for specified network (use default /24 network size)</div>
<div class="line">dhcp-range=192.168.2.0,proxy</div>
<div class="line"> </div>
<div class="line"># Trigger PXE Boot support on HTTP Boot client request</div>
<div class="line">dhcp-pxe-vendor=HTTPClient</div>
<div class="line"> </div>
<div class="line"># Set triggering tag if correct arch is present in option 60</div>
<div class="line">dhcp-match=set:arch_x64,option:client-arch,16</div>
<div class="line"> </div>
<div class="line"># Make PXE Boot support believe it has something to send...</div>
<div class="line">pxe-service=tag:arch_x64,x86-64_EFI,&quot;Network Boot&quot;</div>
<div class="line"> </div>
<div class="line"># Specify bootfile-name via PXE Boot setting</div>
<div class="line">dhcp-boot=tag:arch_x64,https://michaels-air.lan:8443/images/OpenShell.efi</div>
<div class="line"> </div>
<div class="line"># Force required vendor class in response, even if not requested</div>
<div class="line">dhcp-option-force=tag:arch_x64,option:vendor-class,HTTPClient</div>
</div><!-- fragment --><p>To quickly start <code>dnsmasq</code> for testing, without running it as a server, the following command can be used:</p>
<div class="fragment"><div class="line">sudo dnsmasq --no-daemon -C dnsmasq.conf --log-dhcp --log-debug</div>
</div><!-- fragment --><p>An HTTP server (such as Apache, nginx, or multiple other options) will be required to serve the actual NBP files over <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code>.</p>
<p>References:</p><ul>
<li><a href="https://github.com/ipxe/ipxe/discussions/569">https://github.com/ipxe/ipxe/discussions/569</a></li>
<li><a href="https://www.mail-archive.com/dnsmasq-discuss@lists.thekelleys.org.uk/msg16278.html">https://www.mail-archive.com/dnsmasq-discuss@lists.thekelleys.org.uk/msg16278.html</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
HTTPS Boot</h2>
<p>Note that the certificate for validating <code><a href="https://">https://</a></code> requests should be loaded into firmware using the OpenNetworkBoot <code>--enroll-cert</code> option.</p>
<p>A normal https site would not serve files using a self-signed certificate authority (CA), but since we are only attempting to serve files to HTTP boot clients, in this case we can do so.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Booting ISO and IMG files</h1>
<p>Though not often noted in the documentation, the majority of HTTP Boot implementations support loading <code>.iso</code> and <code>.img</code> files, which will be automatically mounted as a ramdisk. If the mounted filesystem includes <code>\EFI\BOOT\BOOTx64.efi</code> (or <code>\EFI\BOOT\BOOTIA32.efi</code> for 32-bit) then this file will be loaded from the ramdisk and started.</p>
<p>The MIME types corresponding to <code>.iso</code> and <code>.img</code> files are:</p>
<ul>
<li><code>application/vnd.efi-iso</code></li>
<li><code>application/vnd.efi-img</code></li>
</ul>
<p>The MIME type for <code>.efi</code> files is:</p>
<ul>
<li><code>application/efi</code></li>
</ul>
<p>If the MIME type is none of the above, then the corresponding file extensions (<code>.iso</code>, <code>.img</code> and <code>.efi</code>) are used instead to identify the NBP file type.</p>
<p>Additionally, for boot options generated by <code>OpenNetworkBoot</code>, <code>.dmg</code> and <code>.chunklist</code> files will be recognised by extension and loaded, regardless of MIME type.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: Files which cannot be recognised by any of the above MIME types or file extensions will <em>not</em> be loaded by HTTP boot drivers. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md25"></a>
Booting DMG files</h1>
<p>In order to allow booting macOS Recovery, <code>OpenNetworkBoot</code> includes additional support for loading <code>.dmg</code> files via HTTP boot. If the NBP filename is <code>{filename}.dmg</code> or <code>{filename}.chunklist</code> then the other file of this pair will be automatically loaded, in order to allow DMG chunklist verification, and both files will be used for OpenCore DMG booting.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
<code>DmgLoading</code> configuration setting</h2>
<p>The behaviour of <code>OpenNetworkBoot</code>'s DMG support depends on the OpenCore <code>DmgLoading</code> setting as follows:</p>
<ul>
<li>If <code>DmgLoading</code> is set to <code>Signed</code> then both <code>.chunklist</code> and <code>.dmg</code> files must be available from the HTTP server. Either file can be specified as the NBP, and the other matching file will be loaded afterwards, automatically.</li>
<li>If <code>DmgLoading</code> is set to <code>Disabled</code> and either of these two file extensions are found as the NBP, then the HTTP boot process will be aborted. (If we allowed these files to load and then passed them to the OpenCore DMG loading process, they would be rejected at that point anyway.)</li>
<li>If <code>DmgLoading</code> is set to <code>Any</code> and the NBP is <code>{filename}.dmg</code> then only the <code>.dmg</code> file will be loaded, as verification via <code>.chunklist</code> is not carried out with this setting. If the NBP is <code>{filename}.chunklist</code> then the <code>.chunklist</code> followed by the <code>.dmg</code> will be loaded, but only the <code>.dmg</code> will be used.</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
OVMF</h1>
<p>OVMF can be compiled with the following flags for full network boot support:</p>
<p><code>-D NETWORK_HTTP_BOOT_ENABLE -D NETWORK_TLS_ENABLE -D NETWORK_IP6_ENABLE</code></p>
<p>Since a May 2024 security update to the network boot stack, Random Number Generator (RNG) protocol support is required. If running OVMF with an Ivy Bridge or above CPU, then the <code>RngDxe</code> driver included in OVMF will provide the required support. For CPUs below Ivy Bridge the QEMU option <code>-device virtio-rng-pci</code> must be provided, so that the <code>VirtioRngDxe</code> driver which is also present in OVMF can provide the required RNG support.</p>
<p>If OVMF is compiled without network boot support (<code>-D NETWORK_ENABLE=0</code>), then network boot support provided with OpenCore may be added by loading the full Network Boot Stack (see below).</p>
<h2><a class="anchor" id="autotoc_md28"></a>
OVMF networking</h2>
<p>If any network boot clients (e.g. OVMF, VMWare) or server programs (e.g. Apache, <code>dnsmasq</code>, WDS) are running on VMs, it is normally easiest to set these up using bridged network support, which allows the VM to appear as a separate device with its own IP address on the network.</p>
<p>To start OVMF with bridged network support the macOS-specific <code>vmnet-bridged</code> QEMU option (which requires <code>sudo</code>) may be used:</p>
<div class="fragment"><div class="line">-netdev vmnet-bridged,id=net0,ifname=en0 \</div>
<div class="line">-device virtio-net-pci,netdev=net0,id=nic0</div>
</div><!-- fragment --><p>PXE boot may also be tested in OVMF using QEMU's built-in TFTP/PXE server, available with the QEMU user mode network stack, for example using the following options:</p>
<div class="fragment"><div class="line">-netdev user,id=net0,tftp=$HOME/tftp,bootfile=/OpenShell.efi \</div>
<div class="line">-device virtio-net-pci,netdev=net0,id=nic0</div>
</div><!-- fragment --><p>No equivalent option is available for HTTP boot, so to experiment with this, a combination such as bridged networking and <code>dnsmasq</code> should be used.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
OVMF HTTPS certificate</h2>
<p>When using <code><a href="https://">https://</a></code> as opposed to <code><a href="http://">http://</a></code>, a certificate must be configured on the network boot client. Within the OVMF menus this may be done using <code>Device Manager/Tls Auth Configuration/Server CA Configuration/Enroll Cert/Enroll Cert Using File</code>.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Tip</b>: No GUID needs to be provided in the above dialog. All zeroes will be used if nothing is specified, which is fine if only a single certificate is going to be configured and managed. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md30"></a>
Debugging network boot on OVMF</h2>
<p>Building OVMF with the <code>-D DEBUG_ON_SERIAL_PORT</code> option and then passing the <code>-serial stdio</code> option to QEMU (and then scrolling back in the output as needed, to the lines generated during a failed network boot) can be very useful when trying to debug network boot setup.</p>
<p>OVMF can capture packets using <code>-object filter-dump,netdev={net-id},id=filter0,file=$HOME/ovmf.cap</code> (<code>{net-id}</code> should be replaced as appropriate with the <code>id</code> value specified in the corresponding <code>-netdev</code> option).</p>
<p>For additional information on debugging OpenCore using OVMF, see <a href="https://github.com/acidanthera/OpenCorePkg/blob/master/Debug/README.md">https://github.com/acidanthera/OpenCorePkg/blob/master/Debug/README.md</a>.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Network Boot Stack</h1>
<p>The following drivers supplied with OpenCore make up the network boot stack. Please follow the procedures given towards the start of this document for deciding which drivers to add.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Prerequisites</h2>
<p>Various network boot drivers depend on the presence of HiiDatabase.</p>
<p>A recent (May 2024) security update to the EDK 2 network stack means that most network stack drivers depend on the RNG protocol and additionally <code>TcpDxe</code> depends on the Hash2 protocol.</p>
<p>These protocols can be checked for in UEFI Shell with:</p>
<div class="fragment"><div class="line">dh -p HIIDatabase</div>
<div class="line">dh -p Rng</div>
<div class="line">dh -p Hash2</div>
</div><!-- fragment --><p>If not present, the respective drivers should be loaded before the network boot stack.</p>
<div class="fragment"><div class="line">HiiDatabase</div>
<div class="line">RngDxe</div>
<div class="line">Hash2DxeCrypto</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
RAM Disk</h2>
<p>Required if not already present in firmware, and the user wishes to load <code>.iso</code> or <code>.img</code> files with HTTP Boot.</p>
<p>Can be checked for in UEFI Shell with <code>dh -p RamDisk</code>.</p>
<div class="fragment"><div class="line">RamDiskDxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Network Boot Base</h2>
<div class="fragment"><div class="line">DpcDxe</div>
<div class="line">SnpDxe</div>
<div class="line">MnpDxe</div>
<div class="line">TcpDxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
IPv4</h2>
<div class="fragment"><div class="line">ArpDxe</div>
<div class="line">Dhcp4Dxe</div>
<div class="line">Ip4Dxe</div>
<div class="line">Udp4Dxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
IPv6</h2>
<div class="fragment"><div class="line">Dhcp6Dxe</div>
<div class="line">Ip6Dxe</div>
<div class="line">Udp6Dxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
HTTP Boot</h2>
<div class="fragment"><div class="line">DnsDxe</div>
<div class="line">HttpDxe</div>
<div class="line">HttpUtilitiesDxe</div>
<div class="line">HttpBootDxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
HTTPS (TLS) support for HTTP Boot</h2>
<div class="fragment"><div class="line">TlsDxe</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
PXE Boot</h2>
<div class="fragment"><div class="line">UefiPxeBcDxe</div>
<div class="line">Mtftp4Dxe (IPv4 only)</div>
<div class="line">Mtftp6Dxe (IPv6 only)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Firmware and option ROMs</h2>
<p>In many situations network card firmware will already be present, but this section covers situations where it may not be.</p>
<p>The EDK II and AUDK versions of OVMF both include <code>VirtioNetDxe</code> by default, even if built with <code>NETWORK_ENABLE=0</code>. This driver produces the base Simple Network Protocol for QEMU <code>virtio-net</code> devices. Therefore, note that if using a cut-down or custom build of OVMF, this driver must be present in order for the rest of the network stack to work. Also note that if using QEMU emulated network hardware such as <code>-device e1000</code>, then although an option ROM for this emulated card is present (and does not require <code>VirtioNetDxe</code>), it is not started automatically in all circumstances, e.g. it is not started when OpenCore is booted directly from OVMF built with no network stack, therefore using a <code>virtio-net</code> device with the <code>VirtioNetDxe</code> driver is a more reliable approach.</p>
<p>Most (U)EFI machines include PXE boot, which relies on the machine's network card firmware (e.g. option ROM) being present already, to provide the base Simple Network Protocol for the rest of the network stack to build on. However, if using a very old (e.g pre-EFI) machine, or one with very cut-down firmware, it may be necessary to manually load the network card's (U)EFI firmware. This may be loaded using OpenCore's <code>Drivers</code> section. Relvant drivers can be found from the manufacturer's website or elsewhere online; for example:</p>
<ul>
<li><a href="https://winraid.level1techs.com/t/efi-lan-bios-intel-gopdriver-modules/33948">https://winraid.level1techs.com/t/efi-lan-bios-intel-gopdriver-modules/33948</a></li>
<li><a href="https://www.intel.com/content/www/us/en/download/15755/intel-ethernet-connections-boot-utility-preboot-images-and-efi-drivers.html">https://www.intel.com/content/www/us/en/download/15755/intel-ethernet-connections-boot-utility-preboot-images-and-efi-drivers.html</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
