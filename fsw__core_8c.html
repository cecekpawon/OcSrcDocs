<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCore: Staging/OpenHfsPlus/fsw_core.c File Reference</title>
<link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LogoApprox.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCore
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">OpenCore Bootloader</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('fsw__core_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fsw_core.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fsw__core_8h_source.html">fsw_core.h</a>&quot;</code><br />
</div>
<p><a href="fsw__core_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aae284c17ae959798536350079ad4ff5c" id="r_aae284c17ae959798536350079ad4ff5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae284c17ae959798536350079ad4ff5c">MAX_CACHE_LEVEL</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="separator:aae284c17ae959798536350079ad4ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0039c73f277465569eb29b4c5487c453" id="r_a0039c73f277465569eb29b4c5487c453"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0039c73f277465569eb29b4c5487c453">START_BUF_SIZE</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a0039c73f277465569eb29b4c5487c453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2996489e8a54b55d1b79f803d309f3ac" id="r_a2996489e8a54b55d1b79f803d309f3ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2996489e8a54b55d1b79f803d309f3ac">SEP_CHAR</a>&#160;&#160;&#160;L'\\'</td></tr>
<tr class="separator:a2996489e8a54b55d1b79f803d309f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad08b172cbf7a2a2a399bde14c08dc843" id="r_ad08b172cbf7a2a2a399bde14c08dc843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad08b172cbf7a2a2a399bde14c08dc843">fsw_mount</a> (void *host_data, struct <a class="el" href="structfsw__host__table.html">fsw_host_table</a> *host_table, struct <a class="el" href="structfsw__fstype__table.html">fsw_fstype_table</a> *fstype_table, struct <a class="el" href="structfsw__volume.html">fsw_volume</a> **vol_out)</td></tr>
<tr class="separator:ad08b172cbf7a2a2a399bde14c08dc843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7d22aceaddd3417aec455c297a4f8" id="r_ad3a7d22aceaddd3417aec455c297a4f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a7d22aceaddd3417aec455c297a4f8">fsw_unmount</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol)</td></tr>
<tr class="separator:ad3a7d22aceaddd3417aec455c297a4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffeffff9fde813c6390a9091543532" id="r_abaffeffff9fde813c6390a9091543532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaffeffff9fde813c6390a9091543532">fsw_volume_stat</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, struct fsw_volume_stat *sb)</td></tr>
<tr class="separator:abaffeffff9fde813c6390a9091543532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3044684383c3a2463632946e7e87e1" id="r_a9b3044684383c3a2463632946e7e87e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3044684383c3a2463632946e7e87e1">fsw_set_blocksize</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> phys_blocksize, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> log_blocksize)</td></tr>
<tr class="separator:a9b3044684383c3a2463632946e7e87e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4705dc4759f0a515ad72a48b010dfd07" id="r_a4705dc4759f0a515ad72a48b010dfd07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4705dc4759f0a515ad72a48b010dfd07">fsw_block_get</a> (struct <a class="el" href="fsw__core_8h.html#a74806299d0aac29043b28dbe15bc33fc">VOLSTRUCTNAME</a> *vol, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> phys_bno, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> cache_level, void **buffer_out)</td></tr>
<tr class="separator:a4705dc4759f0a515ad72a48b010dfd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5328a2b00b468c8c68f105fbff87002" id="r_ac5328a2b00b468c8c68f105fbff87002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5328a2b00b468c8c68f105fbff87002">fsw_block_release</a> (struct <a class="el" href="fsw__core_8h.html#a74806299d0aac29043b28dbe15bc33fc">VOLSTRUCTNAME</a> *vol, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> phys_bno, void *buffer)</td></tr>
<tr class="separator:ac5328a2b00b468c8c68f105fbff87002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb767ae4cdc7ee796fd37fb30e24d8e" id="r_a5cb767ae4cdc7ee796fd37fb30e24d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb767ae4cdc7ee796fd37fb30e24d8e">fsw_dnode_create_root</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> dnode_id, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **dno_out)</td></tr>
<tr class="separator:a5cb767ae4cdc7ee796fd37fb30e24d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ce87e5810086d69dd073852d28079a" id="r_a66ce87e5810086d69dd073852d28079a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ce87e5810086d69dd073852d28079a">fsw_dnode_is_root</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno)</td></tr>
<tr class="separator:a66ce87e5810086d69dd073852d28079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1452f06d8399d50bf81eb9c7ca07ab6" id="r_ae1452f06d8399d50bf81eb9c7ca07ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1452f06d8399d50bf81eb9c7ca07ab6">fsw_dnode_create</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *parent_dno, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> dnode_id, int <a class="el" href="_cpuid_patches_8c.html#a17f325acafe9925be235d6b8356e4c97">type</a>, struct <a class="el" href="structfsw__string.html">fsw_string</a> *name, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **dno_out)</td></tr>
<tr class="separator:ae1452f06d8399d50bf81eb9c7ca07ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc2e1862476b242042db563ff0dbc65" id="r_aebc2e1862476b242042db563ff0dbc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc2e1862476b242042db563ff0dbc65">fsw_dnode_mkcomplete</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno)</td></tr>
<tr class="separator:aebc2e1862476b242042db563ff0dbc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d940363019513570fae61fda515392" id="r_ae4d940363019513570fae61fda515392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4d940363019513570fae61fda515392">fsw_dnode_retain</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno)</td></tr>
<tr class="separator:ae4d940363019513570fae61fda515392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b958c026c4f98400f0ab434b7c52ce" id="r_ae4b958c026c4f98400f0ab434b7c52ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b958c026c4f98400f0ab434b7c52ce">fsw_dnode_release</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno)</td></tr>
<tr class="separator:ae4b958c026c4f98400f0ab434b7c52ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f7b2da1e0aaa50f405805c12e8d3f5" id="r_a45f7b2da1e0aaa50f405805c12e8d3f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45f7b2da1e0aaa50f405805c12e8d3f5">fsw_dnode_fill</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno)</td></tr>
<tr class="separator:a45f7b2da1e0aaa50f405805c12e8d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396d5c8b2b40f90a3d2a76e9d5e2f716" id="r_a396d5c8b2b40f90a3d2a76e9d5e2f716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a396d5c8b2b40f90a3d2a76e9d5e2f716">fsw_dnode_stat</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct fsw_dnode_stat *sb)</td></tr>
<tr class="separator:a396d5c8b2b40f90a3d2a76e9d5e2f716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ac17a88926e707c2c33d8178ac6690" id="r_ac7ac17a88926e707c2c33d8178ac6690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ac17a88926e707c2c33d8178ac6690">fsw_dnode_lookup</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__string.html">fsw_string</a> *lookup_name, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **child_dno_out)</td></tr>
<tr class="separator:ac7ac17a88926e707c2c33d8178ac6690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8152ef5b273f577076ad3ad0cb3b3a5f" id="r_a8152ef5b273f577076ad3ad0cb3b3a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8152ef5b273f577076ad3ad0cb3b3a5f">fsw_dnode_lookup_path</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__string.html">fsw_string</a> *lookup_path, char separator, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **child_dno_out)</td></tr>
<tr class="separator:a8152ef5b273f577076ad3ad0cb3b3a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0939a200243b8eb667434e331c67ad" id="r_a7c0939a200243b8eb667434e331c67ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0939a200243b8eb667434e331c67ad">fsw_dnode_dir_read</a> (struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *shand, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **child_dno_out)</td></tr>
<tr class="separator:a7c0939a200243b8eb667434e331c67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da15e8332a1677600e1686fc196604" id="r_ae7da15e8332a1677600e1686fc196604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7da15e8332a1677600e1686fc196604">fsw_dnode_readlink</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__string.html">fsw_string</a> *target_name)</td></tr>
<tr class="separator:ae7da15e8332a1677600e1686fc196604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf38307e8ecb3fb065eec00e22d1d5e1" id="r_acf38307e8ecb3fb065eec00e22d1d5e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf38307e8ecb3fb065eec00e22d1d5e1">fsw_dnode_readlink_data</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__string.html">fsw_string</a> *link_target)</td></tr>
<tr class="separator:acf38307e8ecb3fb065eec00e22d1d5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78d3e28b7d28079863b4b67913fda5" id="r_acb78d3e28b7d28079863b4b67913fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb78d3e28b7d28079863b4b67913fda5">fsw_dnode_resolve</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **target_dno_out)</td></tr>
<tr class="separator:acb78d3e28b7d28079863b4b67913fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59c3f20c187d9935e14d35e96aa4c35" id="r_ab59c3f20c187d9935e14d35e96aa4c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab59c3f20c187d9935e14d35e96aa4c35">fsw_shandle_open</a> (struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *shand)</td></tr>
<tr class="separator:ab59c3f20c187d9935e14d35e96aa4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5a2daaf6b287b99ae65fa1262bf3fc" id="r_a7d5a2daaf6b287b99ae65fa1262bf3fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5a2daaf6b287b99ae65fa1262bf3fc">fsw_shandle_close</a> (struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *shand)</td></tr>
<tr class="separator:a7d5a2daaf6b287b99ae65fa1262bf3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bd7eda1a758c6456477402f7b6015a" id="r_a17bd7eda1a758c6456477402f7b6015a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17bd7eda1a758c6456477402f7b6015a">fsw_shandle_read</a> (struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *shand, <a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> *buffer_size_inout, void *buffer_in)</td></tr>
<tr class="separator:a17bd7eda1a758c6456477402f7b6015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97efb1b4ab36f3f76db2178377ddcb1" id="r_ab97efb1b4ab36f3f76db2178377ddcb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab97efb1b4ab36f3f76db2178377ddcb1">fsw_dnode_get_path</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *dno, struct <a class="el" href="structfsw__string.html">fsw_string</a> *out_path)</td></tr>
<tr class="separator:ab97efb1b4ab36f3f76db2178377ddcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5a222e90c4ec9ba11db97e81aaeb86" id="r_acb5a222e90c4ec9ba11db97e81aaeb86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb5a222e90c4ec9ba11db97e81aaeb86">fsw_get_bless_info</a> (struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *vol, int <a class="el" href="_cpuid_patches_8c.html#a17f325acafe9925be235d6b8356e4c97">type</a>, struct <a class="el" href="structfsw__string.html">fsw_string</a> *out_path)</td></tr>
<tr class="separator:acb5a222e90c4ec9ba11db97e81aaeb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core file system wrapper abstraction layer code. </p>

<p class="definition">Definition in file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aae284c17ae959798536350079ad4ff5c" name="aae284c17ae959798536350079ad4ff5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae284c17ae959798536350079ad4ff5c">&#9670;&#160;</a></span>MAX_CACHE_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_CACHE_LEVEL&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00045">45</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a2996489e8a54b55d1b79f803d309f3ac" name="a2996489e8a54b55d1b79f803d309f3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2996489e8a54b55d1b79f803d309f3ac">&#9670;&#160;</a></span>SEP_CHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEP_CHAR&#160;&#160;&#160;L'\\'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0039c73f277465569eb29b4c5487c453" name="a0039c73f277465569eb29b4c5487c453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0039c73f277465569eb29b4c5487c453">&#9670;&#160;</a></span>START_BUF_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define START_BUF_SIZE&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4705dc4759f0a515ad72a48b010dfd07" name="a4705dc4759f0a515ad72a48b010dfd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4705dc4759f0a515ad72a48b010dfd07">&#9670;&#160;</a></span>fsw_block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_block_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="fsw__core_8h.html#a74806299d0aac29043b28dbe15bc33fc">VOLSTRUCTNAME</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>phys_bno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>cache_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>buffer_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a block of data from the disk. This function is called by the file system driver or by core functions. It calls through to the host driver's device access routine. Given a physical block number, it reads the block into memory (or fetches it from the block cache) and returns the address of the memory buffer. The caller should provide an indication of how important the block is in the cache_level parameter. Blocks with a low level are purged first. Some suggestions for cache levels:</p>
<ul>
<li>0: File data</li>
<li>1: Directory data, symlink data</li>
<li>2: File system metadata</li>
<li>3..5: File system metadata with a high rate of access</li>
</ul>
<p>If this function returns successfully, the returned data pointer is valid until the caller calls fsw_block_release. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00179">179</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ac5328a2b00b468c8c68f105fbff87002" name="ac5328a2b00b468c8c68f105fbff87002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5328a2b00b468c8c68f105fbff87002">&#9670;&#160;</a></span>fsw_block_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_block_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="fsw__core_8h.html#a74806299d0aac29043b28dbe15bc33fc">VOLSTRUCTNAME</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>phys_bno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a disk block. This function must be called to release disk blocks returned from fsw_block_get. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00267">267</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ae1452f06d8399d50bf81eb9c7ca07ab6" name="ae1452f06d8399d50bf81eb9c7ca07ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1452f06d8399d50bf81eb9c7ca07ab6">&#9670;&#160;</a></span>fsw_dnode_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent_dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>dnode_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new dnode representing a file system object. This function is called by the file system driver in response to directory lookup or read requests. Note that if there already is a dnode with the given dnode_id on record, then no new object is created. Instead, the existing dnode is returned and its reference count increased. All other parameters are ignored in this case.</p>
<p>The type passed into this function may be FSW_DNODE_TYPE_UNKNOWN. It is sufficient to fill the type field during the dnode_fill call.</p>
<p>The name parameter must describe a string with the object's name. A copy will be stored in the dnode structure for future reference. The name will not be used to shortcut directory lookups, but may be used to reconstruct paths.</p>
<p>If the function returns successfully, *dno_out contains a pointer to the dnode that must be released by the caller with fsw_dnode_release. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00372">372</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a5cb767ae4cdc7ee796fd37fb30e24d8e" name="a5cb767ae4cdc7ee796fd37fb30e24d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb767ae4cdc7ee796fd37fb30e24d8e">&#9670;&#160;</a></span>fsw_dnode_create_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_create_root </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>dnode_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a dnode representing the root directory. This function is called by the file system driver while mounting the file system. The root directory is special because it has no parent dnode, its name is defined to be empty, and its type is also fixed. Otherwise, this functions behaves in the same way as fsw_dnode_create. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00323">323</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a7c0939a200243b8eb667434e331c67ad" name="a7c0939a200243b8eb667434e331c67ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0939a200243b8eb667434e331c67ad">&#9670;&#160;</a></span>fsw_dnode_dir_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_dir_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *</td>          <td class="paramname"><span class="paramname"><em>shand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>child_dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next directory item in sequential order. This function is called by the host driver to read the complete contents of a directory in sequential (file system defined) order. Calling this function returns the next entry. Iteration state is kept by a shandle on the directory's dnode. The caller must set up the shandle when starting the iteration.</p>
<p>When the end of the directory is reached, this function returns FSW_NOT_FOUND. If the function returns FSW_SUCCESS, *child_dno_out points to the next directory entry. The caller must call fsw_dnode_release on it. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00669">669</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a45f7b2da1e0aaa50f405805c12e8d3f5" name="a45f7b2da1e0aaa50f405805c12e8d3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f7b2da1e0aaa50f405805c12e8d3f5">&#9670;&#160;</a></span>fsw_dnode_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_fill </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get full information about a dnode from disk. This function is called by the host driver as well as by the core functions. Some file systems defer reading full information on a dnode until it is actually needed (i.e. separation between directory and inode information). This function makes sure that all information is available in the dnode structure. The following fields may not have a correct value until fsw_dnode_fill has been called:</p>
<p>type, size </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00483">483</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ab97efb1b4ab36f3f76db2178377ddcb1" name="ab97efb1b4ab36f3f76db2178377ddcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97efb1b4ab36f3f76db2178377ddcb1">&#9670;&#160;</a></span>fsw_dnode_get_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_get_path </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>out_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00948">948</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a66ce87e5810086d69dd073852d28079a" name="a66ce87e5810086d69dd073852d28079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ce87e5810086d69dd073852d28079a">&#9670;&#160;</a></span>fsw_dnode_is_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsw_dnode_is_root </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00350">350</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ac7ac17a88926e707c2c33d8178ac6690" name="ac7ac17a88926e707c2c33d8178ac6690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ac17a88926e707c2c33d8178ac6690">&#9670;&#160;</a></span>fsw_dnode_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>lookup_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>child_dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup a directory entry by name. This function is called by the host driver. Given a directory dnode and a file name, it looks up the named entry in the directory.</p>
<p>If the dnode is not a directory, the call will fail. The caller is responsible for resolving symbolic links before calling this function.</p>
<p>If the function returns FSW_SUCCESS, *child_dno_out points to the requested directory entry. The caller must call fsw_dnode_release on it. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00529">529</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a8152ef5b273f577076ad3ad0cb3b3a5f" name="a8152ef5b273f577076ad3ad0cb3b3a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8152ef5b273f577076ad3ad0cb3b3a5f">&#9670;&#160;</a></span>fsw_dnode_lookup_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_lookup_path </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>lookup_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>child_dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a file system object by path. This function is called by the host driver. Given a directory dnode and a relative or absolute path, it walks the directory tree until it finds the target dnode. If an intermediate node turns out to be a symlink, it is resolved automatically. If the target node is a symlink, it is not resolved.</p>
<p>If the function returns FSW_SUCCESS, *child_dno_out points to the requested directory entry. The caller must call fsw_dnode_release on it. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00554">554</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="aebc2e1862476b242042db563ff0dbc65" name="aebc2e1862476b242042db563ff0dbc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc2e1862476b242042db563ff0dbc65">&#9670;&#160;</a></span>fsw_dnode_mkcomplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_dnode_mkcomplete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark dnode as 'complete' one </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00420">420</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ae7da15e8332a1677600e1686fc196604" name="ae7da15e8332a1677600e1686fc196604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da15e8332a1677600e1686fc196604">&#9670;&#160;</a></span>fsw_dnode_readlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_readlink </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>target_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the target path of a symbolic link. This function is called by the host driver to read the "content" of a symbolic link, that is the relative or absolute path it points to.</p>
<p>If the function returns FSW_SUCCESS, the string handle provided by the caller is filled with a string in the host's preferred encoding. The caller is responsible for calling fsw_strfree on the string. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00695">695</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="acf38307e8ecb3fb065eec00e22d1d5e1" name="acf38307e8ecb3fb065eec00e22d1d5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf38307e8ecb3fb065eec00e22d1d5e1">&#9670;&#160;</a></span>fsw_dnode_readlink_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_readlink_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>link_target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the target path of a symbolic link by accessing file data. This function can be called by the file system driver if the file system stores the target path as normal file data. This function will open an shandle, read the whole content of the file into a buffer, and build a string from that. Currently the encoding for the string is fixed as FSW_STRING_TYPE_ISO88591.</p>
<p>If the function returns FSW_SUCCESS, the string handle provided by the caller is filled with a string in the host's preferred encoding. The caller is responsible for calling fsw_strfree on the string. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00720">720</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ae4b958c026c4f98400f0ab434b7c52ce" name="ae4b958c026c4f98400f0ab434b7c52ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b958c026c4f98400f0ab434b7c52ce">&#9670;&#160;</a></span>fsw_dnode_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_dnode_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a dnode pointer, deallocating it if this was the last reference. This function decrements the reference counter of the dnode. If the counter reaches zero, the dnode is freed. Since the parent dnode is released during that process, this function may cause it to be freed, too. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00442">442</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="acb78d3e28b7d28079863b4b67913fda5" name="acb78d3e28b7d28079863b4b67913fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb78d3e28b7d28079863b4b67913fda5">&#9670;&#160;</a></span>fsw_dnode_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_resolve </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> **</td>          <td class="paramname"><span class="paramname"><em>target_dno_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resolve a symbolic link. This function can be called by the host driver to make sure the a dnode is fully resolved instead of pointing at a symlink. If the dnode passed in is not a symlink, it is returned unmodified.</p>
<p>Note that absolute paths will be resolved relative to the root directory of the volume. If the host is an operating system with its own VFS layer, it should resolve symlinks on its own.</p>
<p>If the function returns FSW_SUCCESS, *target_dno_out points at a dnode that is not a symlink. The caller is responsible for calling fsw_dnode_release on it. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00764">764</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ae4d940363019513570fae61fda515392" name="ae4d940363019513570fae61fda515392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d940363019513570fae61fda515392">&#9670;&#160;</a></span>fsw_dnode_retain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_dnode_retain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the reference count of a dnode. This must be balanced with fsw_dnode_release calls. Note that some dnode functions return a retained dnode pointer to their caller. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00430">430</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a396d5c8b2b40f90a3d2a76e9d5e2f716" name="a396d5c8b2b40f90a3d2a76e9d5e2f716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396d5c8b2b40f90a3d2a76e9d5e2f716">&#9670;&#160;</a></span>fsw_dnode_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_dnode_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fsw_dnode_stat *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get extended information about a dnode. This function can be called by the host driver to get a full compliment of information about a dnode in addition to the fields of the <a class="el" href="structfsw__dnode.html">fsw_dnode</a> structure itself.</p>
<p>Some data requires host-specific conversion to be useful (i.e. timestamps) and will be passed to callback functions instead of being written into the structure. These callbacks must be filled in by the caller. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00502">502</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="acb5a222e90c4ec9ba11db97e81aaeb86" name="acb5a222e90c4ec9ba11db97e81aaeb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5a222e90c4ec9ba11db97e81aaeb86">&#9670;&#160;</a></span>fsw_get_bless_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_get_bless_info </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__string.html">fsw_string</a> *</td>          <td class="paramname"><span class="paramname"><em>out_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l01039">1039</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ad08b172cbf7a2a2a399bde14c08dc843" name="ad08b172cbf7a2a2a399bde14c08dc843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b172cbf7a2a2a399bde14c08dc843">&#9670;&#160;</a></span>fsw_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_mount </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>host_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__host__table.html">fsw_host_table</a> *</td>          <td class="paramname"><span class="paramname"><em>host_table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__fstype__table.html">fsw_fstype_table</a> *</td>          <td class="paramname"><span class="paramname"><em>fstype_table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> **</td>          <td class="paramname"><span class="paramname"><em>vol_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mount a volume with a given file system driver. This function is called by the host driver to make a volume accessible. The file system driver to use is specified by a pointer to its dispatch table. The file system driver will look at the data on the volume to determine if it can read the format. If the volume is found unsuitable, FSW_UNSUPPORTED is returned.</p>
<p>If this function returns FSW_SUCCESS, *vol_out points at a valid volume data structure. The caller must release it later by calling fsw_unmount.</p>
<p>If this function returns an error status, the caller only needs to clean up its own buffers that may have been allocated through the read_block interface. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00062">62</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a9b3044684383c3a2463632946e7e87e1" name="a9b3044684383c3a2463632946e7e87e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3044684383c3a2463632946e7e87e1">&#9670;&#160;</a></span>fsw_set_blocksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_set_blocksize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>phys_blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a></td>          <td class="paramname"><span class="paramname"><em>log_blocksize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the physical and logical block sizes of the volume. This functions is called by the file system driver to announce the block sizes it wants to use for accessing the disk (physical) and for addressing file contents (logical). Usually both sizes will be the same but there may be file systems that need to access metadata at a smaller block size than the allocation unit for files.</p>
<p>Calling this function causes the block cache to be dropped. All pointers returned from fsw_block_get become invalid. This function should only be called while mounting the file system, not as a part of file access operations.</p>
<p>Both sizes are measured in bytes, must be powers of 2, and must not be smaller than 512 bytes. The logical block size cannot be smaller than the physical block size. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00145">145</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a7d5a2daaf6b287b99ae65fa1262bf3fc" name="a7d5a2daaf6b287b99ae65fa1262bf3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5a2daaf6b287b99ae65fa1262bf3fc">&#9670;&#160;</a></span>fsw_shandle_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_shandle_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *</td>          <td class="paramname"><span class="paramname"><em>shand</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a shandle after accessing the dnode's data. This function is called by the host driver or core functions when they are finished with accessing a file's data. It releases the dnode reference and frees any buffers associated with the shandle itself. The dnode is only released if this was the last reference using it. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00848">848</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ab59c3f20c187d9935e14d35e96aa4c35" name="ab59c3f20c187d9935e14d35e96aa4c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59c3f20c187d9935e14d35e96aa4c35">&#9670;&#160;</a></span>fsw_shandle_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_shandle_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__dnode.html">fsw_dnode</a> *</td>          <td class="paramname"><span class="paramname"><em>dno</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *</td>          <td class="paramname"><span class="paramname"><em>shand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up a shandle (storage handle) to access a file's data. This function is called by the host driver and by the core when they need to access a file's data. It is also used in accessing the raw data of directories and symlinks if the file system uses the same mechanisms for storing the data of those items.</p>
<p>The storage for the <a class="el" href="structfsw__shandle.html">fsw_shandle</a> structure is provided by the caller. The dnode and pos fields may be accessed, pos may also be written to to set the file pointer. The file's data size is available as shand-&gt;dnode-&gt;size.</p>
<p>If this function returns FSW_SUCCESS, the caller must call fsw_shandle_close to release the dnode reference held by the shandle. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00822">822</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="a17bd7eda1a758c6456477402f7b6015a" name="a17bd7eda1a758c6456477402f7b6015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bd7eda1a758c6456477402f7b6015a">&#9670;&#160;</a></span>fsw_shandle_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_shandle_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__shandle.html">fsw_shandle</a> *</td>          <td class="paramname"><span class="paramname"><em>shand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsw__efi__base_8h.html#a675e9bc88277d138411490f178c9018c">fsw_u32</a> *</td>          <td class="paramname"><span class="paramname"><em>buffer_size_inout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer_in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a shandle (storage handle for a dnode). This function is called by the host driver or internally when data is read from a file. TODO: more </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00860">860</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="ad3a7d22aceaddd3417aec455c297a4f8" name="ad3a7d22aceaddd3417aec455c297a4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a7d22aceaddd3417aec455c297a4f8">&#9670;&#160;</a></span>fsw_unmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fsw_unmount </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmount a volume by releasing all memory associated with it. This function is called by the host driver when a volume is no longer needed. It is also called by the core after a failed mount to clean up any allocated memory.</p>
<p>Note that all dnodes must have been released before calling this function. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00107">107</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
<a id="abaffeffff9fde813c6390a9091543532" name="abaffeffff9fde813c6390a9091543532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaffeffff9fde813c6390a9091543532">&#9670;&#160;</a></span>fsw_volume_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsw__core_8h.html#a0fd3729c4a9d1b672ec4a579d6dc57cf">fsw_status_t</a> fsw_volume_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfsw__volume.html">fsw_volume</a> *</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fsw_volume_stat *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get in-depth information on the volume. This function can be called by the host driver to get additional information on the volume. </p>

<p class="definition">Definition at line <a class="el" href="fsw__core_8c_source.html#l00125">125</a> of file <a class="el" href="fsw__core_8c_source.html">fsw_core.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_00f570a50138ea559d143c45d1b62e8f.html">Staging</a></li><li class="navelem"><a class="el" href="dir_e98535183c12cf8133845960104e1df7.html">OpenHfsPlus</a></li><li class="navelem"><a class="el" href="fsw__core_8c.html">fsw_core.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
